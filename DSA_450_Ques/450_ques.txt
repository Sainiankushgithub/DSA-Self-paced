ANKUSH SAINI
DSA 150 DAYS CHALLENGE 450 QUESTIONS





•	DAY 16 :
1.SQRT(X)
class Solution {
public:
    int mySqrt(int x) {
        long long l=0,h=x;
        int result;
        while(l<=h)
        {
            long long mid=(l+h)/2;
            if(mid*mid==x)
            {
                return mid;
            }
            else if(mid*mid<x)
            {
                l=mid+1;
            }
            else
            {
                h=mid-1;
            }
            if(mid*mid<x)
            {
                result=mid;
            }
        }
        return result;
    }
};


2.PLUS ONE
NAÏVE SOLUTION:
Example 1:
Input: digits = [1,2,3]
Output: [1,2,4]
Explanation: The array represents the integer 123.
Incrementing by one gives 123 + 1 = 124.
Thus, the result should be [1,2,4].
Example 2:
Input: digits = [4,3,2,1]
Output: [4,3,2,2]
Explanation: The array represents the integer 4321.
Incrementing by one gives 4321 + 1 = 4322.
Thus, the result should be [4,3,2,2].
Example 3:
Input: digits = [9]
Output: [1,0]
Explanation: The array represents the integer 9.
Incrementing by one gives 9 + 1 = 10.
Thus, the result should be [1,0].


class Solution {
public:
    vector<int> plusOne(vector<int>& digits) {
        vector<int>v;
        int i=digits.size()-1;
        int carry=1;
        while(i>=0)
        {
            v.push_back((digits[i]+carry)%10);
            carry=(digits[i]+carry)/10;
            i--;
        }
        if(carry==1)
        {
            v.push_back(1);
        }
        return vector<int>(v.rbegin(),v.rend());
    }
};
EFFICIENT SOLUTION :
class Solution {
public:
    vector<int> plusOne(vector<int>& digits) {
       int i=digits.size()-1;
       while(i>=0)
       {
           if(digits[i]<9)
           {
               digits[i]++;
               return digits;
           }
           digits[i]=0;
           i--;
       }
       digits.insert(digits.begin(),1);
       return digits;
    }
};







3.ROMAN TO INTEGER
class Solution {
public:
    int romanToInt(string s) {
        int result=0,prev_result=0;
        int i=s.length()-1;
        while(i>=0)
        {
            int value=getValue(s[i]);
            if(prev_result>value)
            {
                result-=value;
            }
            else
            {
                result+=value;
            }
            prev_result=value;
            i--;
        }
        return result;
    }
    private:
    int getValue(char s)
    {
        if(s=='I')
        return 1;
        else if(s=='V')
        return 5;
        else if(s=='L')
        return 50;        
        else if(s=='X')
        return 10;
        else if(s=='C')
        return 100;
        else if(s=='D')
        return 500;
        else
        return 1000;
    }
};

4.HAPPY NUMBER
Happy number doesn’t contain 4 while non happy number always contain 4 after some iteration
Example 1:
Input: n = 19
Output: true
Explanation:
12 + 92 = 82
82 + 22 = 68
62 + 82 = 100
12 + 02 + 02 = 1
Example 2:
Input: n = 2
Output: false
class Solution {
public:
    bool isHappy(int n) {
       int sum=0;
       while(sum!=4)
       {
           sum=0;
           while(n>0)
           {
               sum+=pow((n%10),2);
               n/=10;
           }
           n=sum;
           if(sum==1)
           return true;
       }
       return false;
    }
};


•	DAY 17:
1.Count Odd Number in an range Interval
Example 1:
Input: low = 3, high = 7
Output: 3
Explanation: The odd numbers between 3 and 7 are [3,5,7].
Example 2:
Input: low = 8, high = 10
Output: 1
Explanation: The odd numbers between 8 and 10 are [9].
class Solution {
public:
    int countOdds(int low, int high) {
        int count=0;
        if(low%2==0)
        low++;
        for(int i=low;i<=high;i+=2)
        {
            count++;
        }
        return count;
    }
};
2.Rectangle overlap
An axis-aligned rectangle is represented as a list [x1, y1, x2, y2], where (x1, y1) is the coordinate of its bottom-left corner, and (x2, y2) is the coordinate of its top-right corner. Its top and bottom edges are parallel to the X-axis, and its left and right edges are parallel to the Y-axis.
Two rectangles overlap if the area of their intersection is positive. To be clear, two rectangles that only touch at the corner or edges do not overlap.
Given two axis-aligned rectangles rec1 and rec2, return true if they overlap, otherwise return false.
 
Example 1:
Input: rec1 = [0,0,2,2], rec2 = [1,1,3,3]
Output: true
Example 2:
Input: rec1 = [0,0,1,1], rec2 = [1,0,2,1]
Output: false
Example 3:
Input: rec1 = [0,0,1,1], rec2 = [2,2,3,3]
Output: false
class Solution {
public:
    bool isRectangleOverlap(vector<int>& rec1, vector<int>& rec2) {
        return (rec2[1]>=rec1[3]||rec1[1]>=rec2[3]||rec2[0]>=rec1[2]||rec1[0]>=rec2[2])?false:true;
    }
};

3.Add Digits
Example 1:
Input: num = 38
Output: 2
Explanation: The process is
38 --> 3 + 8 --> 11
11 --> 1 + 1 --> 2 
Since 2 has only one digit, return it.
class Solution {
public:
    int addDigits(int num) {
        int sum=0;
        do
        {
            sum=0;
            while(num>0)
            {
                sum+=(num%10);
                num/=10;
            }
            num=sum;
        }while(sum>=10);
        return sum;
    }
};


4.Maximum Product of three numbers
class Solution {
public:
    int maximumProduct(vector<int>& nums) {
        int n = nums.size();
        sort(nums.begin(), nums.end());
        int max_product = nums[n - 1] * nums[n - 2] * nums[n - 3];
        int alternate_max_product = nums[0] * nums[1] * nums[n - 1];
        return max(max_product, alternate_max_product);
    }
};

5.Excel Sheet Column Number
Example 1:
Input: columnTitle = "A"
Output: 1
Example 2:
Input: columnTitle = "AB"
Output: 28
Example 3:
Input: columnTitle = "ZY"
Output: 701

class Solution {
public:
    int titleToNumber(string s) {
        int res=0;
        for(int i=0;i<s.size();i++)
        {
            int value=s[i]-'A'+1;
            res=res*26+value;
        }return res;
    }
};

•	DAY 18 :
1.Add Binary
Example 1:
Input: a = "11", b = "1"
Output: "100"
class Solution {
public:
    string addBinary(string a, string b) {
        string sum="";
       int i=a.size()-1,j=b.size()-1;
       int carry=0;
       int digit_sum=0;
       while(i>=0 || j>=0 || carry)
       {
           digit_sum=carry;
           if(i>=0)
           {
               digit_sum+=a[i--]-'0';
           }
           if(j>=0)
           {
               digit_sum+=b[j--]-'0';
           }
           sum=to_string(digit_sum%2)+sum;
           carry=digit_sum/2;
       }
       return sum;
    }
};

2.Counting Bits
Input: n = 2
Output: [0,1,1]
Explanation:
0 --> 0
1 --> 1
2 --> 10
Example 2:
Input: n = 5
Output: [0,1,1,2,1,2]
Explanation:
0 --> 0
1 --> 1
2 --> 10
3 --> 11
4 --> 100
5 --> 101

NAÏVE APPROACH :
class Solution {
public:
    vector<int> countBits(int n) {
        // vector<int>v(n+1,0);
        // for(int i=1;i<=n;i++)
        // {
        //     int num=i;
        //     while(num>1)
        //     {
        //         if(num%2==1)
        //         v[i]++;
        //         num=num/2;
        //     }
        //     ++v[i];
        // }
        // return v;
    }
};
EFFICIENT APPROACH: O(n)
class Solution {
public:
    vector<int> countBits(int n) {
         vector<int>v(n+1);
        v[0]=0;
        for(int i=0;i<=n;i++)
        {
            if(i%2!=0)
            {
                v[i]=v[i/2]+1;
            }
            else
            {
                v[i]=v[i/2];
            }
        }
        return v;
    }
};
4.Single Number
Example 1:
Input: nums = [2,2,1]
Output: 1
Example 2:
Input: nums = [4,1,2,1,2]
Output: 4
Example 3:
Input: nums = [1]
Output: 1
class Solution {
public:
    int singleNumber(vector<int>& nums) {
       sort(nums.begin(),nums.end());
       for(int i=1;i<nums.size();i=i+2)
       {
           if(nums[i]!=nums[i-1])
               return nums[i-1];
       }
       return nums[nums.size()-1];
    }
};
5.Missing Number
NAÏVE APPROACH :
Example 1:
Input: nums = [3,0,1]
Output: 2
Example 3:
Input: nums = [9,6,4,2,3,5,7,0,1]
Output: 8
class Solution {
public:
    int missingNumber(vector<int>& nums) {
        sort(nums.begin(),nums.end());
        for(int i=0;i<=nums.size()-1;i++)
        {
            if(nums[i]!=i)
            {
                return i;
            }
        }
        return nums.size();
    }
};

